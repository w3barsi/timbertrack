Operating System Structures
Operating System Structures
▴	Operating System provides the environment within which programs are executed.
▴	These programs include application programs (web browsers, video games, word processors, etc.) and system programs.
       
1 OS Services
Operating System Services
●	An operating system provides an environment for the execution of program. 
The operating system makes certain services available to programs and to the users of those programs.

●	These services are:
○	User-interface 
○	Program Execution
○	I/O Operations
○	File System Manipulation
○	Communications
○	Error-Detection
○	Resource Allocation
○	Logging
○	Protection and Security

User Interface
Almost all operating system have a user interface. User interface can take in several forms. 
These includes graphical user interface (GUI), touch screen interface, command line interface, etc.

Graphical User Interface (GUI)
 
Command line Interface (CLI)
 
Program Execution
The operating system must be able to load a program into memory and to run that program. 
The program must be able to end its execution, either normally or abnormally (indicating error).

I/O Operations
A running program may require I/O, which may involve a file or an I/O device. 
For specific devices, special functions may be desired (such as reading from a network interface or writing to a file system). 
For efficiency and protection, users usually cannot control I/O devices directly. Therefore, the operating system must provide a means to do I/O.

File System Manipulation
Programs need to read and write files and directories. 
They also need to create and delete them by name, search for a given file, and list file information. 
Finally, some operating systems include permissions management to allow or deny access to files or directories based on file ownership

Communications
Communications may be implemented via shared memory, in which two or more processes read and write to a shared section of memory, or message passing, 
in which packets of information in predefined formats are moved between processes by the operating system

Error Detection
The operating system needs to be detecting and correcting errors constantly. 
Errors may occur in the CPU and memory hardware (such as a memory error or a power failure), 
in I/O devices (such as a parity error on disk, a connection failure on a network, or lack of paper in the printer), 
and in the user program (such as an arithmetic overflow or an attempt to access an illegal memory location)

Resource Allocation
When there are multiple processes running at the same time, resources must be allocated to each of the processes.
The operating system manages many different types of resources.

Logging
keep track of which programs use how much and what kinds of computer resources. 
This record keeping may be used for accounting (so that users can be billed) or simply for accumulating usage statistics

Protection and Security
Protection involves ensuring that all access to system resources is controlled. 
Such security starts with requiring each user to authenticate himself or herself to the system, usually by means of a password, to gain access to system resources.

2 Interface  User and OS Interface
User and Operating System Interface
●	An operating system provides an environment for the execution of program. 
The operating system makes certain services available to programs and to the users of those programs.
●	These services are:
○	User-interface 
○	Program Execution
○	I/O Operations
○	File System Manipulation
○	Communications
○	Error-Detection
○	Resource Allocation
○	Logging
○	Protection and Security

Command Interpreters
Most operating systems, including Linux, UNIX, and Windows, 
treat the command interpreter as a special program that is running when a process is initiated or when a user first logs on (on interactive systems).
On systems with multiple command interpreters to choose from, the interpreters are known as shells.
 
Graphical User Interface
A second strategy for interfacing with the operating system is through a user-friendly graphical user interface, or GUI.
Rather than entering commands directly via a command-line interface, users use a mouse-based window and-menu system
 
Touch Screen Interface
Because a either a command-line interface or a mouse-and-keyboard system is impractical for most mobile systems, 
smartphones and handheld tablet computers typically use a touch-screen interface.
 

Choice of Interface
The choice of whether to use a command-line or GUI interface is mostly one of personal preference.

System administrators who manage computers and power users who have deep knowledge of a system frequently use the command-line interface 
as it gives them faster access to the activities they perform.

In contrast, Windows users are happy to use the Windows GUI environment and almost never use the shell interface.

3 System Calls  System calls and types of system calls

System Calls

System calls provide an interface to the services made available by an operating system.
These calls are generally available as functions written in C and C++, although certain low-level (near hardware) tasks 
(for example, tasks where hardware must be accessed directly) may have to be written using assembly-language instructions

Example of System Calls

Let’s have an example how system calls are used. writing a simple program to read data from one file and copy them to another file

Simple Program to read data from one file and copy to another

First, we need to get the names of the two files. 
The input or source file (the file where we will read/get the data from)
The output or destination file (the file where the data is copied to)

One approach is to pass the two file names (input and output)
For example, we’ll use a UNIX cp command (cp command copies files and directories)
You can use UNIX commands on Windows PowerShell

This will copy in.txt into the output out.txt The command will give us another file out.txt

Another approach is to have a program that will ask for the names of the input and output file. In this image, this is a simple C program that asks for the filenames.

This approach will require a sequence of system calls, displayed on the image below
 
Application Programming Interface

1. As you can see, even simple programs may make heavy use of the operating system. Frequently, systems execute thousands of system calls per second. 
2. However, most us programmers never see this level of detail
3. Application developers design programs according to an application programming interface (API).
4. The API specifies a set of functions that are available to an application programmer.

An example of a standard API. This is the read() function that is available to UNIX and LINUX Systems.
As we can see the function has a return value, function name, and parameters in which users can always use the function without going into detail of system calls.

Types of System Calls

●	System Calls can be grouped into 6 major categories:
●	These categories are:
○	Process-Control	 
○	File Management
○	Device Management
○	Information Maintenance
○	Communications
○	Protection
Process Control

A running program needs to be able to stop its execution either normally (end()) or abnormally (abort())
If a system call makes a running program stops abnormally or if it runs into a problem, a dump of memory is sometimes taken, and an error message is generated
 
1. create process, terminate process
2. load, execute 
3. get process attributes
4. set process attributes 
5. wait event, signal event 
6. allocate and free memory

Double Clicking or Click and press enter will run the executable of the program. 
The executable file (.exe) contains the instructions while the files along the .exe are the data/information (other codes, images, character models etc.) the .exe processes.
 
Example game as the process: 
While the program is running, it will look for events (keyboard press, mouse press etc.) and signal the events for the computer to process (character movements, menu etc.)
 
Quitting the game normally or ending the task in task manager  will end() the running process (the game).
 
If the program goes through a system call that causes the program to give an error and stop, this will end the program abnormally (not normal) and abort() the program.
 
The dump is written in a special log file and can be examined by a debugger.
Debugger aids programmers in helping and correcting errors, or bugs
 
1. create process, terminate process
2. load, execute 
3. get process attributes
4. set process attributes 
5. wait event, signal event 
6. allocate and free memory

For example, if the Windows operating system crashes (BSOD etc.), it creates a .dmp file where programmers can use the .dmp file to track the errors or bugs.

File Management

These are the functions for file management.
1. create file, delete file 
2. open, close 
3. read, write, reposition 
4. get file attributes, set file attributes

We first need to be able to create() and delete() files. Either system call requires the name of the file and perhaps some of the file’s attributes.
Once the file is created, we need to open() it and to use it. We may also read(), write(), or reposition() (rewind or skip to the end of the file, for example).
 
Finally, we need to close() the file, indicating that we are no longer using it.

Virtual Representation of directories/files
 
This will create() the file. Creating the file will need the filename and some attributes like if it is read-only (cannot write) or hidden etc.

Double clicking or click and press enter will open() the file, read() the contents and can write() contents (save programs/files etc.).
The user can also reposition() the files.
 
Clicking X will close() the folder, stopping the current read() and write() functionality of the folder while not opened.
 
This will delete() the folder/directory, along with all the files inside the folder/directory.
 
Device Management

A process may need several resources to execute—main memory, disk drives, access to files, and so on. 
If the resources are available, they can be granted, and control can be returned to the user process. 
Otherwise, the process will have to wait until enough resources are available. 

1. request device, release device 
2. read, write, reposition 
3. get device attributes, set device attributes
4. logically attach or detach devices

The various resources controlled by the operating system can be thought of as devices. 
Some of these devices are physical devices (for example, hard disk drives or SSDs), 
while others can be thought of as abstract or virtual devices (for example, files).

Virtual Representation of your hard disk drives or SSDs
 
Virtual != physical where you can physically touch the devices
 
Solid State Drives (SSD), can be physically interacted

Information Maintenance
Many system calls exist simply for the purpose of transferring information between the user program and the operating system.

1. get time or date, set time or date 
2. get system data, set system data 
3. get process, file, or device attributes
4. set process, file, or device attributes

For example, most systems have a system call to set the current time() and date(). 
 
20:30 is 8:30 in 24-hour format

Communications

There are two common models of interprocess communication: the messagepassing model and the shared-memory model.

1. create, delete communication connection 
2. send, receive messages 
3. transfer status information 
4. attach or detach remote devices

In the message-passing model, the communicating processes exchange messages with one another to transfer information.

In the shared-memory model, processes use shared memory create() and shared memory attach() system calls 
to create and gain access to regions of memory owned by other processes

Protection

Protection provides a mechanism for controlling access to the resources provided by a computer system.
System calls providing protection includes set permission() and get permission(), 
which changes or modifies the permission settings of resources such as files and disks.

1. get file permissions 
2. set file permissions

Examples of Windows and Unix System Calls

EXAMPLES OF WINDOWS AND UNIX SYSTEM CALLS

The following illustrates various equivalent system calls for Windows and UNIX operating systems. 

Process control

Windows : CreateProcess() , ExitProcess() , WaitForSingleObject()
Unix : fork() , exit() , wait()

File management

Windows : CreateFile() , ReadFile() , WriteFile() , CloseHandle()
Unix: open() , read() , write() , close()

Device management

Windows : SetConsoleMode() , ReadConsole() , WriteConsole()
Unix : ioctl() , read() , write()

Information maintenance

Windows : GetCurrentProcessID() , SetTimer() , Sleep()
Unix : getpid() , alarm() , sleep()

Communications

Windows : CreatePipe() , CreateFileMapping() , MapViewOfFile()
Unix : pipe() , shm_open() , mmap()

Protection

Windows : SetFileSecurity() , InitializeSecurityDescriptor() , SetSecurityDescriptorGroup()
Unix : chmod() , umask() , chown()

4 OS Design  Operating System Design and implementation

Design Goals
The first problem in designing a system is to define goals and specifications.
the design of the system will be affected by the choice of hardware and the type of system: traditional desktop/laptop, mobile, distributed, or real time.

Beyond the design, the requirements may be much harder to specify. However, they can be divided into two groups, user goals and system goals

User Goals

The system should be convenient to use, easy to learn and to use, reliable, safe, and fast.

Easy to use Operating System (Windows)

WTF?? (TempleOS)
 
System Goals

A similar set of requirements can be defined by the developers who must design, create, maintain, and operate the system:
The system should be easy to design, implement, and maintain; and it should be flexible, reliable, error free, and efficient.

Mechanisms and Policies

One important principle is the separation of policy from mechanism. 
1. Mechanisms determine how to do something 
2. Policies determine what will be done

For example, the timer (the timer where it sets an interrupt with a fixed or variable time, the one we discussed before) 
construct is a mechanism for ensuring CPU protection, but deciding how long the timer is to be set for a particular user is a policy decision

Implementation

Once an operating system is designed, it must be implemented. 
Because operating systems are collections of many programs, written by many people over a long period of time, 
it is difficult to make general statements about how they are implemented

Early operating systems were written in assembly language. Now, most are written in higher-level languages such as C or C++, 
with small parts of the system written in assembly language.

5 OS Structure  Operating System Structure

Operating System Structure

A system as large and complex as a modern operating system must be engineered carefully if it is to function properly and be modified easily.
A common approach is to partition the task into small components, or modules, rather than have one single system.

(the users)
---------------
Shells and commands 
Compilers and interpreters
System libraries
---------------
K	system-call interface to the kernel
E	signals terminal		file system		CPU scheduling
R	handling		swapping block I/O	page replacement
N	character I/O system	system			demand paging
E	terminal drivers		disk and tape drivers	virtual memory
L	kernel interface of the hardware
---------------
Terminal controllers terminals|device controllers disks and tapes|memory controllers physical memory
Figure 2.12 Traditional UNIX system structure.

Monolithic Structure
The simplest structure for organizing an operating system is no structure at all. 
That is, place all the functionality of the kernel into a single, static binary fill. 
This approach—known as a monolithic structure—is a common technique for designing operating systems.

An example of such limited structuring is the original UNIX operating system, which consists of two separable parts: the kernel and the system

Layered Approach

The monolithic approach is often known as a tightly coupled system because changes to one part of the system can have wide-ranging effects on other parts. 
Alternatively, we could design a loosely coupled system.

Such a system is divided into separate, smaller components that have specific and limited functionality. 
All these components together makes up the kernel. The advantage of this modular approach is that changes 
in one component affect only that component, and no others.

A system can be made modular in many ways. 
One method is the layered approach, in which the operating system is broken into several layers (levels). 
The bottom layer (layer 0) is the hardware; the highest (layer N) is the user interface (the one that we interact with our computers)

Microkernels

This method structures the operating system by removing all nonessential components from the kernel and implementing them as user level programs

Hybrid Systems
In practice, very few operating systems adopt a single, strictly defined structure. 
Instead, they combine different structures, resulting in hybrid systems that address performance, security, and usability issues.

3 Hybrid Systems to be discussed
	1. macOS and iOS
	2. Android

macOS and iOS
Apple’s macOS operating system is designed to run primarily on desktop and laptop computer systems, 
whereas iOS is a mobile operating system designed for the iPhone smartphone and iPad tablet computer

macOS & iOS General Architecture

Image on the right is the general architecture for macOS and iOS. The architecture consists of multiple layers (layered approach).

Applications
User experience
Application frameworks
Core frameworks
Kernel environment (Darwin)

User Experience

This layer defines the software interface that allows users to interact with the devices. 
macOS uses the Aqua user interface, which is designed for a mouse or trackpad, whereas iOS uses the Springboard user interface, which is designed for touch devices.

Application Frameworks

This layer includes the Cocoa and Cocoa Touch frameworks, which provide an API for the Objective-C and Swift programming languages. 
The primary difference between Cocoa and Cocoa Touch is Coca is used for developing macOS applications, 
and the Coca Touch by iOS to provide support for hardware features unique to mobile devices, such as touch screens

Core Frameworks
This layer defines frameworks that support graphics and media including, Quicktime and OpenGL.

Kernel Environment
This environment, also known as Darwin, includes the Mach microkernel and the BSD UNIX kernel. 

Android
The Android operating system was designed by the Open Handset Alliance (led primarily by Google) and was developed for Android smartphones and tablet computers.

Software designers for Android devices develop applications in the Java language, but they do not generally use the standard Java API. 
Google has designed a separate Android API for Java development.

Android is similar to iOS in that it is a layered stack of software that provides a rich set of frameworks supporting graphics, audio, and hardware features.

==============================================================================================================================================================================
ASSIGNMENTS===================================================================================================================================================================
Research Assignment 1

Recall 
1. In simple terms and in your own words, What happens during an interrupt? 
An interrupt is a signal from an input/output device that gives a request to the CPU, 
which then processes this request and gives an output.

2. What is the memory hierarchy? Identify and rank the memory storage in the hierarchy based on the storage capacity and CPU access time.
  The memory hierarchy is a basis of computer architecture on how the Operating Systems responds to different types of computer storage. 
The higher in the hierarchy, the smaller the storage capacity and faster the access time, and vice versa.

Memory Hierarchy
Primary Storage	

Volatile Storage	 
The higher in the hierarchy, the smaller the storage capacity, and faster the CPU access time.
1.	Registers
2.	Cache
3.	Main Memory			
Secondary Storage	

Nonvolatile Storage		
4.	Nonvolatile Memory			
5.	Hard-disk drives			The lower in the hierarchy, the larger the storage capacity, and slower the CPU access time.
Tertiary Storage			
6.	Optical disk			
7.	Magnetic tapes			
  
3. Why is I/O device management in Operating Systems? 
Because I/O device management is the only way that users can interact and communicate with the computer. 
Without this kind management, computers wouldn’t be able to give information out of its system 
without any instructions given by the user with the help of I/O devices.

Advance Research
 Computer Architecture 
•	Single Processor Systems 
 Single processor systems only contain one processor. With this, processes can be executed one at a time.
•	Multi-Processor Systems 
 Multi-Processor systems contain two or more processors. With this, multiple processes can be executed simultaneously.
•	Clustered Systems
  Clustered systems are a combination of hardware and software clusters. These clusters share storage, and works together as a whole. 
Operating System operations
•	Multi Programming/Multi Tasking
 Multi Programming/Multi Tasking is when computers run more than one program at a time, such as doing more than one task simultaneously. 
•	Dual mode and Multi mode operation
 Dual mode and multi mode operations ensure proper execution of processes for the operating system, 
because an error in a program would widely affect other processes that are running. 

Dual mode has the following modes which are: 
User mode, where the operating system is handling an application that a user is handling, 
and the Kernel mode, where the operating system handles itself, where it also executes applications in user mode that are however, 
privileged and some of these applications may not be accessed by the user. 
Multi mode operations are only in systems that support virtualization, 
such as running a virtual machine, and a virtualization management software is used to handle this.

•	Timer
 Timers in operating systems are set to interrupt the CPU after a specific period of time, which is usually used to prevent user programs from running too long.

==============================================================================================================================================================================
ASSIGNMENTS===================================================================================================================================================================
Research Assignment 2

Research Assignment II
Recall

1.	What is Multiprogramming and Multitasking?
Multiprogramming and Multitasking helps in CPU utilization, where it organizes programs for the CPU to work efficiently. 
This is usually seen where multiple processes or tasks are executed simultaneously.

2.	What is Dual Mode Operation?
A dual mode operation is a concept wherein modes can be extended between modes. It ensures proper execution of processes for the operating system.

3.	List some resources that an operating system manages.
Some resources that an operating system manages include:
 Processes, Memory, File-Systems, Mass-storage, and Cache
Advance Research

1.	Computing Environments
•	Traditional Computing
Traditional Computing is the use of physical computers for storing digital assets, 
such as physical data centers running a complete networking system for daily operations. 
It is more on the transmission of different servers locally, 
and takes place on physical hard drives and website servers, 
and data can only be accessed through the system in wherein the data was stored.

•	Mobile Computing
Mobile Computing are devices and software that enable wireless access to services, 
such as transporting and transmission data, videos, 
or any kind of media using mobile devices such as smart phones or laptops.

•	Cloud Computing
Cloud Computing is the utilization of the delivery of computing services, such as servers, storage, databases, and networking. 
It is the on-demand availability of computer system resources, such as storing and accessing data and programs over the internet 
instead of using your computer for storing such things. 

2.	Open-Source Operating Systems
Open-source operating systems are openly distributed program code, and are free of charge, 
and allows users to modify or utilize these kinds of operating systems without restriction. 

These open-source operating systems are more flexible when it comes to rules and restrictions, 
as it allows corporations or companies and even developers to impose certain licenses to protect the integrity of the open-source code. 

Open-source operating systems has its advantages, such as its constant improvement, 
for there are many developers that can Implement new features and such. 
And as stated before, the code can be modified and to be configured to our own liking with our own specific needs.

More importantly, open-source is free, and is always becoming better and better. 
There are a lot of examples regarding open-source operating systems, 
such as Linux when it comes to computers, and Android when it comes to mobile phones.
